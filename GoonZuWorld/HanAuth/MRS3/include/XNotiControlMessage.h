// This file, generated by XDR Compiler for C++ version 1.0.2220. Release: Feb 17 2006. 16:36:02.

#ifndef __XDR_XNotiControlMessage__
#define __XDR_XNotiControlMessage__

#include <XDR.h>

#ifndef __XDR_MESSAGE_XNotiSvcIncInfo_147397898__
#define __XDR_MESSAGE_XNotiSvcIncInfo_147397898__
class XNotiSvcIncInfo : public XDR::IMessage
{
public:
    enum {tagMsgID = 147397898};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    int32 m_nIPAddr;
    int32 m_nServiceStartTime;
    char m_arMRAddr[16];
    std::string m_strHostName;
    std::string m_strDomainName;
    std::string m_strService;
    std::string m_strServiceInstanceID;

public:
    XNotiSvcIncInfo(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
        m_nIPAddr = 0;
        m_nServiceStartTime = 0;
        memset(m_arMRAddr, 0, sizeof(char) * 16);
    }
    virtual ~XNotiSvcIncInfo(void)
    {
    }

    virtual void Clear(void)
    {
        m_nIPAddr = 0;
        m_nServiceStartTime = 0;
        memset(m_arMRAddr, 0, sizeof(char) * 16);
        m_strHostName.resize(0);
        m_strDomainName.resize(0);
        m_strService.resize(0);
        m_strServiceInstanceID.resize(0);
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiSvcIncInfo";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_nIPAddr);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_nIPAddr);
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_nServiceStartTime);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_nServiceStartTime);
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(m_arMRAddr, 16);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(m_arMRAddr, 16);
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_strHostName);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_strHostName);
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_strDomainName);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_strDomainName);
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_strService);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_strService);
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_strServiceInstanceID);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_strServiceInstanceID);
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_nIPAddr
        if (XDR::EncodingRules::Save(hStream, &m_nIPAddr) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_nIPAddr
        if (XDR::EncodingRules::Save(hStream, &m_nIPAddr) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_nServiceStartTime
        if (XDR::EncodingRules::Save(hStream, &m_nServiceStartTime) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_nServiceStartTime
        if (XDR::EncodingRules::Save(hStream, &m_nServiceStartTime) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_arMRAddr
        if (XDR::EncodingRules::Save(hStream, m_arMRAddr, 16) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_arMRAddr
        if (XDR::EncodingRules::Save(hStream, m_arMRAddr, 16) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_strHostName
        if (XDR::EncodingRules::Save(hStream, &m_strHostName) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_strHostName
        if (XDR::EncodingRules::Save(hStream, &m_strHostName) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_strDomainName
        if (XDR::EncodingRules::Save(hStream, &m_strDomainName) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_strDomainName
        if (XDR::EncodingRules::Save(hStream, &m_strDomainName) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_strService
        if (XDR::EncodingRules::Save(hStream, &m_strService) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_strService
        if (XDR::EncodingRules::Save(hStream, &m_strService) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_strServiceInstanceID
        if (XDR::EncodingRules::Save(hStream, &m_strServiceInstanceID) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_strServiceInstanceID
        if (XDR::EncodingRules::Save(hStream, &m_strServiceInstanceID) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_nIPAddr
        if (XDR::EncodingRules::Load(hStream, &m_nIPAddr) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_nIPAddr
        if (XDR::EncodingRules::Load(hStream, &m_nIPAddr) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_nServiceStartTime
        if (XDR::EncodingRules::Load(hStream, &m_nServiceStartTime) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_nServiceStartTime
        if (XDR::EncodingRules::Load(hStream, &m_nServiceStartTime) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_arMRAddr
        if (XDR::EncodingRules::Load(hStream, m_arMRAddr, 16) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_arMRAddr
        if (XDR::EncodingRules::Load(hStream, m_arMRAddr, 16) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_strHostName
        if (XDR::EncodingRules::Load(hStream, &m_strHostName) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_strHostName
        if (XDR::EncodingRules::Load(hStream, &m_strHostName) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_strDomainName
        if (XDR::EncodingRules::Load(hStream, &m_strDomainName) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_strDomainName
        if (XDR::EncodingRules::Load(hStream, &m_strDomainName) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_strService
        if (XDR::EncodingRules::Load(hStream, &m_strService) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_strService
        if (XDR::EncodingRules::Load(hStream, &m_strService) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_strServiceInstanceID
        if (XDR::EncodingRules::Load(hStream, &m_strServiceInstanceID) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_strServiceInstanceID
        if (XDR::EncodingRules::Load(hStream, &m_strServiceInstanceID) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiSvcIncInfo_147397898__

#ifndef __XDR_MESSAGE_XNotiChannelInfo_41323770__
#define __XDR_MESSAGE_XNotiChannelInfo_41323770__
class XNotiChannelInfo : public XDR::IMessage
{
public:
    enum {tagMsgID = 41323770};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    char m_arMRAddr[16];

public:
    XNotiChannelInfo(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
        memset(m_arMRAddr, 0, sizeof(char) * 16);
    }
    virtual ~XNotiChannelInfo(void)
    {
    }

    virtual void Clear(void)
    {
        memset(m_arMRAddr, 0, sizeof(char) * 16);
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiChannelInfo";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(m_arMRAddr, 16);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(m_arMRAddr, 16);
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_arMRAddr
        if (XDR::EncodingRules::Save(hStream, m_arMRAddr, 16) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_arMRAddr
        if (XDR::EncodingRules::Save(hStream, m_arMRAddr, 16) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_arMRAddr
        if (XDR::EncodingRules::Load(hStream, m_arMRAddr, 16) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_arMRAddr
        if (XDR::EncodingRules::Load(hStream, m_arMRAddr, 16) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiChannelInfo_41323770__

#ifndef __XDR_MESSAGE_XNotiGetRegisterredSvcIncInfoReq_137752938__
#define __XDR_MESSAGE_XNotiGetRegisterredSvcIncInfoReq_137752938__
class XNotiGetRegisterredSvcIncInfoReq : public XDR::IMessage
{
public:
    enum {tagMsgID = 137752938};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    XNotiSvcIncInfo m_xdrmsgSvcIncInfo;

public:
    XNotiGetRegisterredSvcIncInfoReq(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
    }
    virtual ~XNotiGetRegisterredSvcIncInfoReq(void)
    {
    }

    virtual void Clear(void)
    {
        m_xdrmsgSvcIncInfo.Clear();
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiGetRegisterredSvcIncInfoReq";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_xdrmsgSvcIncInfo);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_xdrmsgSvcIncInfo);
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Save(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Save(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Load(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Load(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiGetRegisterredSvcIncInfoReq_137752938__

#ifndef __XDR_MESSAGE_XNotiGetRegisterredSvcIncInfoAns_248984458__
#define __XDR_MESSAGE_XNotiGetRegisterredSvcIncInfoAns_248984458__
class XNotiGetRegisterredSvcIncInfoAns : public XDR::IMessage
{
public:
    enum {tagMsgID = 248984458};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    int32 m_nRetCode;
    XNotiSvcIncInfo m_xdrmsgSvcIncInfo;

public:
    XNotiGetRegisterredSvcIncInfoAns(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
        m_nRetCode = 0;
    }
    virtual ~XNotiGetRegisterredSvcIncInfoAns(void)
    {
    }

    virtual void Clear(void)
    {
        m_nRetCode = 0;
        m_xdrmsgSvcIncInfo.Clear();
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiGetRegisterredSvcIncInfoAns";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_nRetCode);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_nRetCode);
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_xdrmsgSvcIncInfo);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_xdrmsgSvcIncInfo);
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_nRetCode
        if (XDR::EncodingRules::Save(hStream, &m_nRetCode) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_nRetCode
        if (XDR::EncodingRules::Save(hStream, &m_nRetCode) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Save(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Save(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_nRetCode
        if (XDR::EncodingRules::Load(hStream, &m_nRetCode) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_nRetCode
        if (XDR::EncodingRules::Load(hStream, &m_nRetCode) == false)
        {
            return false;
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Load(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Load(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiGetRegisterredSvcIncInfoAns_248984458__

#ifndef __XDR_MESSAGE_XNotiRegistrationSvcIncInfoReq_207184186__
#define __XDR_MESSAGE_XNotiRegistrationSvcIncInfoReq_207184186__
class XNotiRegistrationSvcIncInfoReq : public XDR::IMessage
{
public:
    enum {tagMsgID = 207184186};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    XNotiSvcIncInfo m_xdrmsgSvcIncInfo;

public:
    XNotiRegistrationSvcIncInfoReq(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
    }
    virtual ~XNotiRegistrationSvcIncInfoReq(void)
    {
    }

    virtual void Clear(void)
    {
        m_xdrmsgSvcIncInfo.Clear();
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiRegistrationSvcIncInfoReq";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_xdrmsgSvcIncInfo);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_xdrmsgSvcIncInfo);
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Save(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Save(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Load(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Load(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiRegistrationSvcIncInfoReq_207184186__

#ifndef __XDR_MESSAGE_XNotiUnregistrationSvcIncInfoReq_142138__
#define __XDR_MESSAGE_XNotiUnregistrationSvcIncInfoReq_142138__
class XNotiUnregistrationSvcIncInfoReq : public XDR::IMessage
{
public:
    enum {tagMsgID = 142138};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    XNotiSvcIncInfo m_xdrmsgSvcIncInfo;

public:
    XNotiUnregistrationSvcIncInfoReq(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
    }
    virtual ~XNotiUnregistrationSvcIncInfoReq(void)
    {
    }

    virtual void Clear(void)
    {
        m_xdrmsgSvcIncInfo.Clear();
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiUnregistrationSvcIncInfoReq";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_xdrmsgSvcIncInfo);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_xdrmsgSvcIncInfo);
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Save(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Save(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Load(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Load(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiUnregistrationSvcIncInfoReq_142138__

#ifndef __XDR_MESSAGE_XNotiGetServiceInstanceReq_37447722__
#define __XDR_MESSAGE_XNotiGetServiceInstanceReq_37447722__
class XNotiGetServiceInstanceReq : public XDR::IMessage
{
public:
    enum {tagMsgID = 37447722};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    XNotiGetServiceInstanceReq(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
    }
    virtual ~XNotiGetServiceInstanceReq(void)
    {
    }

    virtual void Clear(void)
    {
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiGetServiceInstanceReq";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiGetServiceInstanceReq_37447722__

#ifndef __XDR_MESSAGE_XNotiGetServiceInstanceAns_18428730__
#define __XDR_MESSAGE_XNotiGetServiceInstanceAns_18428730__
class XNotiGetServiceInstanceAns : public XDR::IMessage
{
public:
    enum {tagMsgID = 18428730};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    XNotiSvcIncInfo m_xdrmsgSvcIncInfo;

public:
    XNotiGetServiceInstanceAns(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
    }
    virtual ~XNotiGetServiceInstanceAns(void)
    {
    }

    virtual void Clear(void)
    {
        m_xdrmsgSvcIncInfo.Clear();
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiGetServiceInstanceAns";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_xdrmsgSvcIncInfo);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_xdrmsgSvcIncInfo);
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Save(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Save(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Load(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_xdrmsgSvcIncInfo
        if (XDR::EncodingRules::Load(hStream, &m_xdrmsgSvcIncInfo) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiGetServiceInstanceAns_18428730__

#ifndef __XDR_MESSAGE_XNotiJoinMRSGroupNetworkReq_8385514__
#define __XDR_MESSAGE_XNotiJoinMRSGroupNetworkReq_8385514__
class XNotiJoinMRSGroupNetworkReq : public XDR::IMessage
{
public:
    enum {tagMsgID = 8385514};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    typedef std::list<XNotiChannelInfo *> m_listNoticeChannelInfoType;
    m_listNoticeChannelInfoType m_listNoticeChannelInfo;

public:
    XNotiJoinMRSGroupNetworkReq(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
    }
    virtual ~XNotiJoinMRSGroupNetworkReq(void)
    {
        while (m_listNoticeChannelInfo.empty() == false)
        {
            XNotiChannelInfo *pItem = m_listNoticeChannelInfo.back();
            m_listNoticeChannelInfo.pop_back();
            delete pItem;
        }
    }

    virtual void Clear(void)
    {
        while (m_listNoticeChannelInfo.empty() == false)
        {
            XNotiChannelInfo *pItem = m_listNoticeChannelInfo.back();
            m_listNoticeChannelInfo.pop_back();
            delete pItem;
        }
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiJoinMRSGroupNetworkReq";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_listNoticeChannelInfo);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        {nLength += sizeof(int32);
        for (m_listNoticeChannelInfoType::iterator it = m_listNoticeChannelInfo.begin(); it != m_listNoticeChannelInfo.end(); ++it)
        {
            nLength += XDR::EncodingRules::GetLength(*it);
        }}
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_listNoticeChannelInfo
        if (XDR::EncodingRules::Save(hStream, &m_listNoticeChannelInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_listNoticeChannelInfo
        {int32 nLength = static_cast<int32>(m_listNoticeChannelInfo.size());
        if (XDR::EncodingRules::Save(hStream, &nLength) == false)
        {
            return false;
        }

        for (m_listNoticeChannelInfoType::iterator it = m_listNoticeChannelInfo.begin(); it != m_listNoticeChannelInfo.end(); ++it)
        {
            if (XDR::EncodingRules::Save(hStream, *it) == false)
            {
                return false;
            }
        }}
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_listNoticeChannelInfo
        if (XDR::EncodingRules::Load(hStream, &m_listNoticeChannelInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_listNoticeChannelInfo
        {int32 nLength = 0;
        if (XDR::EncodingRules::Load(hStream, &nLength) == false)
        {
            return false;
        }

        for (int i = 0; i < nLength; ++i)
        {
            XNotiChannelInfo *pItem = new XNotiChannelInfo;
            if (XDR::EncodingRules::Load(hStream, pItem) == false)
            {
                return false;
            }
            m_listNoticeChannelInfo.push_back(pItem);
        }}
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiJoinMRSGroupNetworkReq_8385514__

#ifndef __XDR_MESSAGE_XNotiJoinMRSGroupNetworkAns_63642234__
#define __XDR_MESSAGE_XNotiJoinMRSGroupNetworkAns_63642234__
class XNotiJoinMRSGroupNetworkAns : public XDR::IMessage
{
public:
    enum {tagMsgID = 63642234};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    typedef std::list<XNotiChannelInfo *> m_listJoinFailedNoticeChannelInfoType;
    m_listJoinFailedNoticeChannelInfoType m_listJoinFailedNoticeChannelInfo;

public:
    XNotiJoinMRSGroupNetworkAns(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
    }
    virtual ~XNotiJoinMRSGroupNetworkAns(void)
    {
        while (m_listJoinFailedNoticeChannelInfo.empty() == false)
        {
            XNotiChannelInfo *pItem = m_listJoinFailedNoticeChannelInfo.back();
            m_listJoinFailedNoticeChannelInfo.pop_back();
            delete pItem;
        }
    }

    virtual void Clear(void)
    {
        while (m_listJoinFailedNoticeChannelInfo.empty() == false)
        {
            XNotiChannelInfo *pItem = m_listJoinFailedNoticeChannelInfo.back();
            m_listJoinFailedNoticeChannelInfo.pop_back();
            delete pItem;
        }
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiJoinMRSGroupNetworkAns";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_listJoinFailedNoticeChannelInfo);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        {nLength += sizeof(int32);
        for (m_listJoinFailedNoticeChannelInfoType::iterator it = m_listJoinFailedNoticeChannelInfo.begin(); it != m_listJoinFailedNoticeChannelInfo.end(); ++it)
        {
            nLength += XDR::EncodingRules::GetLength(*it);
        }}
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_listJoinFailedNoticeChannelInfo
        if (XDR::EncodingRules::Save(hStream, &m_listJoinFailedNoticeChannelInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_listJoinFailedNoticeChannelInfo
        {int32 nLength = static_cast<int32>(m_listJoinFailedNoticeChannelInfo.size());
        if (XDR::EncodingRules::Save(hStream, &nLength) == false)
        {
            return false;
        }

        for (m_listJoinFailedNoticeChannelInfoType::iterator it = m_listJoinFailedNoticeChannelInfo.begin(); it != m_listJoinFailedNoticeChannelInfo.end(); ++it)
        {
            if (XDR::EncodingRules::Save(hStream, *it) == false)
            {
                return false;
            }
        }}
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_listJoinFailedNoticeChannelInfo
        if (XDR::EncodingRules::Load(hStream, &m_listJoinFailedNoticeChannelInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_listJoinFailedNoticeChannelInfo
        {int32 nLength = 0;
        if (XDR::EncodingRules::Load(hStream, &nLength) == false)
        {
            return false;
        }

        for (int i = 0; i < nLength; ++i)
        {
            XNotiChannelInfo *pItem = new XNotiChannelInfo;
            if (XDR::EncodingRules::Load(hStream, pItem) == false)
            {
                return false;
            }
            m_listJoinFailedNoticeChannelInfo.push_back(pItem);
        }}
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiJoinMRSGroupNetworkAns_63642234__

#ifndef __XDR_MESSAGE_XNotiLeaveMRSGroupNetworkReq_34417738__
#define __XDR_MESSAGE_XNotiLeaveMRSGroupNetworkReq_34417738__
class XNotiLeaveMRSGroupNetworkReq : public XDR::IMessage
{
public:
    enum {tagMsgID = 34417738};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    typedef std::list<XNotiChannelInfo *> m_listNoticeChannelInfoType;
    m_listNoticeChannelInfoType m_listNoticeChannelInfo;

public:
    XNotiLeaveMRSGroupNetworkReq(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
    }
    virtual ~XNotiLeaveMRSGroupNetworkReq(void)
    {
        while (m_listNoticeChannelInfo.empty() == false)
        {
            XNotiChannelInfo *pItem = m_listNoticeChannelInfo.back();
            m_listNoticeChannelInfo.pop_back();
            delete pItem;
        }
    }

    virtual void Clear(void)
    {
        while (m_listNoticeChannelInfo.empty() == false)
        {
            XNotiChannelInfo *pItem = m_listNoticeChannelInfo.back();
            m_listNoticeChannelInfo.pop_back();
            delete pItem;
        }
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiLeaveMRSGroupNetworkReq";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_listNoticeChannelInfo);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        {nLength += sizeof(int32);
        for (m_listNoticeChannelInfoType::iterator it = m_listNoticeChannelInfo.begin(); it != m_listNoticeChannelInfo.end(); ++it)
        {
            nLength += XDR::EncodingRules::GetLength(*it);
        }}
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_listNoticeChannelInfo
        if (XDR::EncodingRules::Save(hStream, &m_listNoticeChannelInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_listNoticeChannelInfo
        {int32 nLength = static_cast<int32>(m_listNoticeChannelInfo.size());
        if (XDR::EncodingRules::Save(hStream, &nLength) == false)
        {
            return false;
        }

        for (m_listNoticeChannelInfoType::iterator it = m_listNoticeChannelInfo.begin(); it != m_listNoticeChannelInfo.end(); ++it)
        {
            if (XDR::EncodingRules::Save(hStream, *it) == false)
            {
                return false;
            }
        }}
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_listNoticeChannelInfo
        if (XDR::EncodingRules::Load(hStream, &m_listNoticeChannelInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_listNoticeChannelInfo
        {int32 nLength = 0;
        if (XDR::EncodingRules::Load(hStream, &nLength) == false)
        {
            return false;
        }

        for (int i = 0; i < nLength; ++i)
        {
            XNotiChannelInfo *pItem = new XNotiChannelInfo;
            if (XDR::EncodingRules::Load(hStream, pItem) == false)
            {
                return false;
            }
            m_listNoticeChannelInfo.push_back(pItem);
        }}
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiLeaveMRSGroupNetworkReq_34417738__

#ifndef __XDR_MESSAGE_XNotiLeaveMRSGroupNetworkAns_128226218__
#define __XDR_MESSAGE_XNotiLeaveMRSGroupNetworkAns_128226218__
class XNotiLeaveMRSGroupNetworkAns : public XDR::IMessage
{
public:
    enum {tagMsgID = 128226218};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    typedef std::list<XNotiChannelInfo *> m_listLeaveFailedNoticeChannelInfoType;
    m_listLeaveFailedNoticeChannelInfoType m_listLeaveFailedNoticeChannelInfo;

public:
    XNotiLeaveMRSGroupNetworkAns(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
    }
    virtual ~XNotiLeaveMRSGroupNetworkAns(void)
    {
        while (m_listLeaveFailedNoticeChannelInfo.empty() == false)
        {
            XNotiChannelInfo *pItem = m_listLeaveFailedNoticeChannelInfo.back();
            m_listLeaveFailedNoticeChannelInfo.pop_back();
            delete pItem;
        }
    }

    virtual void Clear(void)
    {
        while (m_listLeaveFailedNoticeChannelInfo.empty() == false)
        {
            XNotiChannelInfo *pItem = m_listLeaveFailedNoticeChannelInfo.back();
            m_listLeaveFailedNoticeChannelInfo.pop_back();
            delete pItem;
        }
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiLeaveMRSGroupNetworkAns";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_listLeaveFailedNoticeChannelInfo);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        {nLength += sizeof(int32);
        for (m_listLeaveFailedNoticeChannelInfoType::iterator it = m_listLeaveFailedNoticeChannelInfo.begin(); it != m_listLeaveFailedNoticeChannelInfo.end(); ++it)
        {
            nLength += XDR::EncodingRules::GetLength(*it);
        }}
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_listLeaveFailedNoticeChannelInfo
        if (XDR::EncodingRules::Save(hStream, &m_listLeaveFailedNoticeChannelInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_listLeaveFailedNoticeChannelInfo
        {int32 nLength = static_cast<int32>(m_listLeaveFailedNoticeChannelInfo.size());
        if (XDR::EncodingRules::Save(hStream, &nLength) == false)
        {
            return false;
        }

        for (m_listLeaveFailedNoticeChannelInfoType::iterator it = m_listLeaveFailedNoticeChannelInfo.begin(); it != m_listLeaveFailedNoticeChannelInfo.end(); ++it)
        {
            if (XDR::EncodingRules::Save(hStream, *it) == false)
            {
                return false;
            }
        }}
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_listLeaveFailedNoticeChannelInfo
        if (XDR::EncodingRules::Load(hStream, &m_listLeaveFailedNoticeChannelInfo) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_listLeaveFailedNoticeChannelInfo
        {int32 nLength = 0;
        if (XDR::EncodingRules::Load(hStream, &nLength) == false)
        {
            return false;
        }

        for (int i = 0; i < nLength; ++i)
        {
            XNotiChannelInfo *pItem = new XNotiChannelInfo;
            if (XDR::EncodingRules::Load(hStream, pItem) == false)
            {
                return false;
            }
            m_listLeaveFailedNoticeChannelInfo.push_back(pItem);
        }}
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiLeaveMRSGroupNetworkAns_128226218__

#ifndef __XDR_MESSAGE_XNotiGetJoinedXNotiChannelListReq_210457354__
#define __XDR_MESSAGE_XNotiGetJoinedXNotiChannelListReq_210457354__
class XNotiGetJoinedXNotiChannelListReq : public XDR::IMessage
{
public:
    enum {tagMsgID = 210457354};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    XNotiGetJoinedXNotiChannelListReq(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
    }
    virtual ~XNotiGetJoinedXNotiChannelListReq(void)
    {
    }

    virtual void Clear(void)
    {
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiGetJoinedXNotiChannelListReq";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiGetJoinedXNotiChannelListReq_210457354__

#ifndef __XDR_MESSAGE_XNotiGetJoinedXNotiChannelListAns_48556058__
#define __XDR_MESSAGE_XNotiGetJoinedXNotiChannelListAns_48556058__
class XNotiGetJoinedXNotiChannelListAns : public XDR::IMessage
{
public:
    enum {tagMsgID = 48556058};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    typedef std::list<XNotiChannelInfo *> m_listJoinedXNotiChannelListType;
    m_listJoinedXNotiChannelListType m_listJoinedXNotiChannelList;

public:
    XNotiGetJoinedXNotiChannelListAns(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
    }
    virtual ~XNotiGetJoinedXNotiChannelListAns(void)
    {
        while (m_listJoinedXNotiChannelList.empty() == false)
        {
            XNotiChannelInfo *pItem = m_listJoinedXNotiChannelList.back();
            m_listJoinedXNotiChannelList.pop_back();
            delete pItem;
        }
    }

    virtual void Clear(void)
    {
        while (m_listJoinedXNotiChannelList.empty() == false)
        {
            XNotiChannelInfo *pItem = m_listJoinedXNotiChannelList.back();
            m_listJoinedXNotiChannelList.pop_back();
            delete pItem;
        }
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiGetJoinedXNotiChannelListAns";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_listJoinedXNotiChannelList);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        {nLength += sizeof(int32);
        for (m_listJoinedXNotiChannelListType::iterator it = m_listJoinedXNotiChannelList.begin(); it != m_listJoinedXNotiChannelList.end(); ++it)
        {
            nLength += XDR::EncodingRules::GetLength(*it);
        }}
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_listJoinedXNotiChannelList
        if (XDR::EncodingRules::Save(hStream, &m_listJoinedXNotiChannelList) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_listJoinedXNotiChannelList
        {int32 nLength = static_cast<int32>(m_listJoinedXNotiChannelList.size());
        if (XDR::EncodingRules::Save(hStream, &nLength) == false)
        {
            return false;
        }

        for (m_listJoinedXNotiChannelListType::iterator it = m_listJoinedXNotiChannelList.begin(); it != m_listJoinedXNotiChannelList.end(); ++it)
        {
            if (XDR::EncodingRules::Save(hStream, *it) == false)
            {
                return false;
            }
        }}
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_listJoinedXNotiChannelList
        if (XDR::EncodingRules::Load(hStream, &m_listJoinedXNotiChannelList) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_listJoinedXNotiChannelList
        {int32 nLength = 0;
        if (XDR::EncodingRules::Load(hStream, &nLength) == false)
        {
            return false;
        }

        for (int i = 0; i < nLength; ++i)
        {
            XNotiChannelInfo *pItem = new XNotiChannelInfo;
            if (XDR::EncodingRules::Load(hStream, pItem) == false)
            {
                return false;
            }
            m_listJoinedXNotiChannelList.push_back(pItem);
        }}
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiGetJoinedXNotiChannelListAns_48556058__

#ifndef __XDR_MESSAGE_XNotiSetReportingIntervalForSvcIncInfoReq_99275498__
#define __XDR_MESSAGE_XNotiSetReportingIntervalForSvcIncInfoReq_99275498__
class XNotiSetReportingIntervalForSvcIncInfoReq : public XDR::IMessage
{
public:
    enum {tagMsgID = 99275498};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    int32 m_nInterval;

public:
    XNotiSetReportingIntervalForSvcIncInfoReq(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
        m_nInterval = 0;
    }
    virtual ~XNotiSetReportingIntervalForSvcIncInfoReq(void)
    {
    }

    virtual void Clear(void)
    {
        m_nInterval = 0;
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiSetReportingIntervalForSvcIncInfoReq";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_nInterval);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_nInterval);
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_nInterval
        if (XDR::EncodingRules::Save(hStream, &m_nInterval) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_nInterval
        if (XDR::EncodingRules::Save(hStream, &m_nInterval) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_nInterval
        if (XDR::EncodingRules::Load(hStream, &m_nInterval) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_nInterval
        if (XDR::EncodingRules::Load(hStream, &m_nInterval) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiSetReportingIntervalForSvcIncInfoReq_99275498__

#ifndef __XDR_MESSAGE_XNotiSetReportingIntervalForSvcIncInfoAns_63987914__
#define __XDR_MESSAGE_XNotiSetReportingIntervalForSvcIncInfoAns_63987914__
class XNotiSetReportingIntervalForSvcIncInfoAns : public XDR::IMessage
{
public:
    enum {tagMsgID = 63987914};

protected:
    bool bSubMessageFlag;
    int32 nMsgID;

public:
    // User defined data fields
    int32 m_nRetCode;

public:
    XNotiSetReportingIntervalForSvcIncInfoAns(void) : bSubMessageFlag(false), nMsgID(tagMsgID)
    {
        m_nRetCode = 0;
    }
    virtual ~XNotiSetReportingIntervalForSvcIncInfoAns(void)
    {
    }

    virtual void Clear(void)
    {
        m_nRetCode = 0;
    }
    virtual int32 GetID(void) const
    {
        return tagMsgID;
    }
    virtual const char *GetName(void) const
    {
        return "XNotiSetReportingIntervalForSvcIncInfoAns";
    }
    virtual int32 GetLength(void)
    {
        int32 nLength = 0;

#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            nLength += XDR::EncodingRules::GetLength(&nMsgID);
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        nLength += XDR::EncodingRules::GetLength(&m_nRetCode);
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        nLength += XDR::EncodingRules::GetLength(&m_nRetCode);
#endif

        return nLength;
    }
    virtual bool Save(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Save(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_nRetCode
        if (XDR::EncodingRules::Save(hStream, &m_nRetCode) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_nRetCode
        if (XDR::EncodingRules::Save(hStream, &m_nRetCode) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual bool Load(XStream::THandle hStream)
    {
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        if (bSubMessageFlag == false)
        {
            if (XDR::EncodingRules::Load(hStream, &nMsgID) == false)
            {
                return false;
            }
        }
#endif
#if (_MSC_VER >= 1301) || defined(_UNIX_)
        // m_nRetCode
        if (XDR::EncodingRules::Load(hStream, &m_nRetCode) == false)
        {
            return false;
        }
#elif (_MSC_VER >= 1200)
        // Visual C++ 6.0
        // m_nRetCode
        if (XDR::EncodingRules::Load(hStream, &m_nRetCode) == false)
        {
            return false;
        }
#endif

        return true;
    }
    virtual void SetSubMessageFlag(bool bSubMessageFlag)
    {
        this->bSubMessageFlag = bSubMessageFlag;
    }
    virtual bool GetSubMessageFlag(void) const
    {
        return bSubMessageFlag;
    }
};
#endif // __XDR_MESSAGE_XNotiSetReportingIntervalForSvcIncInfoAns_63987914__

#endif
